Вашему вниманию предлагается набор приложений, предназначенных для сопоставления эффективности многопоточного,
мнгопроцессного и асинхронного подходов к программированию ресурсоёмких процессов, таких как множественная обработка
HTTP-запросов для скачивания изображений и, собственно, работа по преобразованию этих изображений.

В процессе разработки использовался Python 3.11. Используемые библиотеки виртуального окружения - см. requirements.txt.

Предусматриваются два этапа анализа, реализованные независимо друг от друга.

На первом этапе осуществляются множественные HTTPзапросы для скачивания изображений. Реализация этого этапа предполагает
обход URL-адресов, указанных в списке urls (строка 10 в get_images.py). При этом осуществляется поочерёдный запуск
модулей request_sequential.py, request_threading.py, request_processing.py и request_async.py, осуществляющих HTTP-
запросы по указанным URL-адресам, соответственно, последовательным, многопоточным, многопроцессным и простым асинхронным
образом. Скачивание изображений осуществляется в папку images_source.

В строке 25 основного модуля get_images.py задаётся именованная константа NUMBER_OF_REPEATS (по умолчанию, равная 2),
определяющая количество запусков внешних циклов для реализации повторных обходов заданных URL-адресов. Повторные обходы
рекомендуются для "сглаживания" эффектов нестабильного Интернет-соединения, приводящих либо к заметному увеличению
времени отклика, либо, вообще, к отказу запроса. С учётом реалий неустойчивости Интернета в городе Белгороде приходилось
задавать указанную константу равной 10. При этом значении время решения задач первого этапа составляло около 30 минут.

В папке sample находится файл output.txt, содержащий протокол одного из запусков с указанным значением константы. По
тексту протокола интуитивно понятны производимые программой действия. Кроме того, подтверждается устойчивость программы
к отказам HTTP-запросов.

Максимальное количество используемых потоков (Thread) задаётся в строках 26-27 get_images.py. Здесь выбирается меньшее
из значений длины списка URL-адресов и заданного максимума THREADS_LIMIT (по умолчанию - 10).

Максимальное количество используемых процессов (Process) определяется результатом запроса количества ядер процессора.

На втором этапе осуществляется преобразование изображений, находящихся в папке images_source (они могут быть помещены в
эту папку и непосредственным образом без этапа обязательного скачивания из Интернета, например, из папки reserve_copy).
При этом каждый из файлов в этой папке проверяется на соответствие файлу изображений с последующим исключением
неподходящих файлов из списка анализируемых. Таким файлом, например, является файл no_image.jpg в папке reserve_copy.

Второй этап анализа осуществляется также с использованием последовательного, многопоточного, многопроцессного и
асинхронного методов. Для этого используются программные файлы image_no_red_sequential.py, image_no_red_threading.py,
image_no_red_processing.py и image_no_red_async.py соответственно. Кроме того, за счёт использования асинхронной
библиотеки concurrent.futures добавлена реализация асинхронно-многопоточного и асинхронно-многопроцессного подходов. Эта
реализация соответствует файлам image_no_red_async_thread.py и image_no_red_async_process.py. Все указанные приложения,
в отличие от первого этапа, запускаются независимо друг от друга в любом порядке. При этом важно иметь в виду, что для
выполнения корректного анализа и создания актуального отчёта требуется запуск всех указанных приложений при изменении
набора файлов изображений в папке images_source.

Дополнительными приложениями второго этапа являются image_inverse_by_iter.py и image_inverse_by_matrix.py. С их помощью
осуществляется преобразование изображений, находящихся в папке images_source путём инвертирования всех их цветов. При
этом в первом случае преобразование происходит путём обхода каждого пикселя трёхмерной матрицы, а во втором - за счёт
намного более быстрой операции по трансформированию всей матрицы. Результаты при этом получаются идентичными, а
затраченное на преобразование время отличается в десятки раз. Это сделано для того, чтобы обратить внимание на
приоритетную важность использования наиболее оптимальных операций, особенно в контексте необходимости повышения скорости
работы приложений. Ведь понижающий эффект от выбора неоптимальных методов расчёта может оказаться куда значительнее
преимуществ, получаемых от параллельного программирования.

Отметим также, что для анализа возможностей различных подходов к параллельному программированию использовалась как раз
неоптимальная операция по "обнулению" красного канала каждого изображения методом последовательного обхода всех пикселей
целого слоя матрицы. Это было сделано намеренно для создания относительно длительной нагрузки на ресурсы компьютера и
анализа эффектов от применения различных подходов по возможному ускорению работы программ именно в таких условиях.

В модуле paths_filenames хранятся имена необходимых файлов для генерации отчёта, а также ключевые пути.

Модифицированные изображения записываются в папку images_dest.

Для генерации отчётов используется create_report.py. После его запуска генерируется файл report.html в папке for report.
Генерация отчёта может быть активирована в любое время (по поводу актуальности создаваемого отчёта см. выше).